{"version":3,"sources":["webpack:///./src/datatypes.ts","webpack:///./src/_piping-ui-auth.ts"],"names":["rsaOtherPrimesInfoType","d","r","t","ecJsonWebKeyType","kty","alg","crv","dp","dq","e","ext","k","key_ops","n","oth","p","q","qi","use","x","y","keyExchangeParcelType","version","keyExchangeV1ParcelType","encryptPublicJwk","verifiedParcelType","verified","utilsAsync","jwkThumbprintAsync","uint8ArrayToStringAsync","then","uint8ArrayToString","urlJoinAsync","default","keyExchangePath","type","secretPath","utils","sha256","verifiedPath","keyExchange","serverUrl","KEY_EXCHANGE_VERSION","KEY_BITS","window","crypto","subtle","generateKey","name","namedCurve","keyPair","exportKey","publicKey","publicKeyJwk","keyExchangeParcel","urlJoin","myPath","peerPath","Promise","all","fetch","method","body","JSON","stringify","peerRes","text","parse","peerPublicKeyExchangeEither","decode","_tag","errorCode","peerPublicKeyExchange","right","peerPublicKeyExchangeV1Either","peerPublicKeyExchangeV1","importKey","peerPublicKey","deriveBits","public","privateKey","keyBits","generateVerificationCode","verificationCode","key","Uint8Array","publicJwk1","publicJwk2","jwkThumbprintByEncoding","hashes","sort","join","substring","keyExchangeAndReceiveVerified","protection","setVerificationStep","undefined","password","keyExchangeRes","errorMessage","lang","strings","path","res","arrayBuffer","decrypt","decryptedBody","verifiedParcelEither"],"mappings":"6oBAeMA,EAAyB,OAAU,CACvCC,EAAG,OACHC,EAAG,OACHC,EAAG,SAECC,EAAmB,OAAe,CACtC,OAAO,CACLC,IAAK,OAAU,QAEjB,OAAU,CACRC,IAAK,OACLC,IAAK,OACLN,EAAG,OACHO,GAAI,OACJC,GAAI,OACJC,EAAG,OACHC,IAAK,OACLC,EAAG,OACHC,QAAS,OAAQ,QACjBC,EAAG,OACHC,IAAK,OAAQf,GACbgB,EAAG,OACHC,EAAG,OACHC,GAAI,OACJC,IAAK,OACLC,EAAG,OACHC,EAAG,WAIMC,EAAwB,OAAO,CAC1CC,QAAS,SAIEC,EAA0B,OAAO,CAC5CD,QAAS,OAAU,GAEnBE,iBAAkBrB,IAIPsB,EAAqB,OAAO,CACvCC,SAAU,S,YC7CNC,EAAa,kBAAM,6CAEnBC,EAAsB,kBAAM,0FAC5BC,EAA0B,kBAAM,oDAA8CC,MAAK,SAAAf,GAAC,OAAIA,EAAEgB,uBAC1FC,EAAe,kBAAM,gDAAmBF,MAAK,SAAAf,GAAC,OAAIA,EAAEkB,Y,SAE3CC,E,kGAAf,WAA+BC,EAA6BC,GAA5D,uGACsBT,IADtB,cACQU,EADR,yBAESA,EAAMC,OAAN,UAAgBF,EAAhB,yBAA2CD,KAFpD,2C,wBAKO,SAAeI,EAAtB,kC,8DAAO,WAA4BH,GAA5B,uGACeT,IADf,cACCU,EADD,yBAEEA,EAAMC,OAAN,UAAgBF,EAAhB,eAFF,2C,wBAUA,SAAeI,EAAtB,sC,8DAAO,WAA2BC,EAAmBN,EAA6BC,GAA3E,gIACCM,EAAuB,EAEvBC,EAAW,IAHZ,SAKgCC,OAAOC,OAAOC,OAAOC,YACxD,CAAEC,KAAM,OAAQC,WAAY,UAC5B,EACA,CAAC,YAAa,eARX,cAKCC,EALD,gBAYsBL,OAAOC,OAAOK,UACvC,MACAD,EAAQE,WAdL,cAYCC,EAZD,OAgBCC,EAAyC,CAC7ChC,QAASoB,EACTlB,iBAAkB6B,GAlBf,UAoBiBrB,IApBjB,eAoBCuB,EApBD,iBAqBgBrB,EAAgBC,EAAMC,GArBtC,eAqBCoB,EArBD,iBAsBkBtB,EAAyB,WAATC,EAAoB,WAAa,SAAUC,GAtB7E,eAsBCqB,EAtBD,iBAwBqBC,QAAQC,IAAI,CACpCC,MAAML,EAAQd,EAAWe,GAAS,CAACK,OAAQ,OAAQC,KAAMC,KAAKC,UAAUV,KACxEM,MAAML,EAAQd,EAAWgB,MA1BtB,8CAwBIQ,EAxBJ,UA4B8D5C,EA5B9D,KA4B2F0C,KA5B3F,UA4B4GE,EAAQC,OA5BpH,iCA4BgGC,MA5BhG,gBA4BCC,EA5BD,KA4BoFC,OA5BpF,gBA6BoC,SAArCD,EAA4BE,KA7B3B,0CA8BI,CAACnC,KAAM,QAASoC,UAAW,0BA9B/B,WAgCCC,EAAwBJ,EAA4BK,MACtD/B,IAAyB8B,EAAsBlD,QAjC9C,0CAkCI,CAACa,KAAM,QAASoC,UAAW,mCAlC/B,WAoCCG,EAAgCnD,EAAwB8C,OAAOG,GAC1B,SAAvCE,EAA8BJ,KArC7B,0CAsCI,CAACnC,KAAM,QAASoC,UAAW,6BAtC/B,eAwCCI,EAA0BD,EAA8BD,MAxCzD,UAyCuB5B,OAAOC,OAAO8B,UACxC,MACAD,EAAwBnD,iBACxB,CAACwB,KAAM,OAAQC,WAAY,UAC3B,EACA,IA9CG,eAyCC4B,EAzCD,iBAgD8BhC,OAAOC,OAAOgC,WAC/C,CAAE9B,KAAM,OAAQ+B,OAAQF,GACxB3B,EAAQ8B,WACRrC,GAnDG,eAgDCsC,EAhDD,iBAqD0BC,EAAyB7B,EAAcsB,EAAwBnD,kBArDzF,eAqDC2D,EArDD,yBAsDE,CACLhD,KAAM,MACNiD,IAAK,IAAIC,WAAWJ,GACpBE,qBAzDG,4C,iCA6DQD,E,kGAAf,WAAwCI,EAAwBC,GAAhE,6GAC0C3D,IAD1C,uBACS4D,EADT,EACSA,wBACDC,EAAS,CACbD,EAAwBF,EAAY,UAAW,OAC/CE,EAAwBD,EAAY,UAAW,QAJnD,SAMsB5D,IANtB,cAMQU,EANR,iBAOgBA,EAAMC,OAAOmD,EAAOC,OAAOC,KAAK,MAPhD,wCAOuDC,UAAU,EAAG,KAPpE,4C,wBAUO,SAAeC,EAAtB,wC,8DAAO,WAA6CpD,EAAmBL,EAAoB0D,EAAwBC,GAA5G,gHAKGD,EAAW3D,KALd,OAME,QANF,OAWE,aAXF,OAgBE,iBAhBF,gDAOM,CACLA,KAAM,MACNiD,SAAKY,IATN,gCAYM,CACL7D,KAAM,MACNiD,IAAKU,EAAWG,WAdjB,uBAkB4BzD,EAAYC,EAAW,WAAYL,GAlB/D,UAkBK8D,EAlBL,OAmB2B,UAAxBA,EAAe/D,KAnBlB,wBAoBC4D,EAAoB,CAAC5D,KAAM,UApB5B,kBAqBQ,CACLA,KAAM,QACNgE,aAFK,SAEQC,GACX,OAAO,OAAAC,EAAA,MAAQD,GAAM,sBAAsBF,EAAe3B,cAxB/D,eA4BMa,EAAyBc,EAAzBd,IAAKD,EAAoBe,EAApBf,iBACZY,EAAoB,CAAC5D,KAAM,4BAA6BgD,mBAAkBC,QA7BzE,UA8BgCvD,IA9BhC,eA8BKE,EA9BL,iBA+BqBC,IA/BrB,eA+BKuB,EA/BL,YAgCYA,EAhCZ,KAgCoBd,EAhCpB,UAgCqCF,EAAaH,GAhClD,2BAgCKkE,GAhCL,6BAkCiB1C,MAAM0C,GAlCvB,eAkCKC,EAlCL,iBAmCmB5E,IAnCnB,eAmCKU,EAnCL,YAqCuCA,EArCvC,KAqCyDgD,WArCzD,UAqC0EkB,EAAIC,cArC9E,oDAqC8FpB,EArC9F,eAqC6CqB,QArC7C,gCAqCKC,EArCL,OAuCKC,EAAmDlF,EAAmB4C,OAAON,KAAKI,MAAMpC,EAAmB2E,KAC/E,SAA9BC,EAAqBrC,KAxCxB,0CAyCQ,CACLnC,KAAM,QACNgE,aAFK,SAEQC,GACX,OAAO,OAAAC,EAAA,MAAQD,GAAM,sBAAsB,4BA5ChD,WAgDM1E,EAAYiF,EAAqBlC,MAAjC/C,SACPqE,EAAoB,CAAC5D,KAAM,WAAYT,aAClCA,EAlDJ,0CAmDQ,CACLS,KAAM,QACNgE,aAFK,SAEQC,GACX,OAAO,OAAAC,EAAA,MAAQD,GAAM,0BAtD1B,iCA0DM,CACLjE,KAAM,MACNiD,QA5DD,4C","file":"js/piping-ui-auth.299d00de.js","sourcesContent":["import * as t from 'io-ts';\n\nexport type Protection = NoProtection | PasswordProtection| PasswordlessProtection;\ntype NoProtection = {\n  type: 'raw'\n};\ntype PasswordProtection = {\n  type: 'password',\n  password: string,\n};\n// Password-inputless protection\ntype PasswordlessProtection = {\n  type: 'passwordless',\n};\n\nconst rsaOtherPrimesInfoType = t.partial({\n  d: t.string,\n  r: t.string,\n  t: t.string,\n});\nconst ecJsonWebKeyType = t.intersection([\n  t.type({\n    kty: t.literal('EC'),\n  }),\n  t.partial({\n    alg: t.string,\n    crv: t.string,\n    d: t.string,\n    dp: t.string,\n    dq: t.string,\n    e: t.string,\n    ext: t.boolean,\n    k: t.string,\n    key_ops: t.array(t.string),\n    n: t.string,\n    oth: t.array(rsaOtherPrimesInfoType),\n    p: t.string,\n    q: t.string,\n    qi: t.string,\n    use: t.string,\n    x: t.string,\n    y: t.string,\n  })\n]);\n\nexport const keyExchangeParcelType = t.type({\n  version: t.number,\n});\nexport type KeyExchangeParcel = t.TypeOf<typeof keyExchangeParcelType>;\n\nexport const keyExchangeV1ParcelType = t.type({\n  version: t.literal(1),\n  // Public JWK for encryption\n  encryptPublicJwk: ecJsonWebKeyType,\n});\nexport type KeyExchangeV1Parcel = t.TypeOf<typeof keyExchangeV1ParcelType>;\n\nexport const verifiedParcelType = t.type({\n  verified: t.boolean,\n});\nexport type VerifiedParcel = t.TypeOf<typeof verifiedParcelType>\n\nexport type VerificationStep =\n  {type: 'initial'} |\n  {type: 'error'} |\n  {type: 'verification_code_arrived', verificationCode: string, key: Uint8Array} |\n  {type: 'verified', verified: boolean};\n","// NOTE: Use `const pipingUiAuthAsync = import(/* webpackChunkName: \"piping-ui-auth\" */ \"@/_piping-ui-auth\");` to import this file\n\nimport {\n  KeyExchangeParcel,\n  keyExchangeParcelType,\n  KeyExchangeV1Parcel,\n  keyExchangeV1ParcelType,\n  Protection, VerificationStep,\n  VerifiedParcel,\n  verifiedParcelType\n} from \"@/datatypes\";\nimport {strings} from \"@/strings\";\nimport type {Validation} from \"io-ts\";\nconst utilsAsync = () => import(\"@/utils\");\n\nconst jwkThumbprintAsync  = () => import(\"jwk-thumbprint\");\nconst uint8ArrayToStringAsync = () => import('binconv/dist/src/uint8ArrayToString').then(p => p.uint8ArrayToString);\nconst urlJoinAsync = () => import('url-join').then(p => p.default);\n\nasync function keyExchangePath(type: 'sender' | 'receiver', secretPath: string): Promise<string> {\n  const utils = await utilsAsync();\n  return utils.sha256(`${secretPath}/key_exchange/${type}`);\n}\n\nexport async function verifiedPath(secretPath: string): Promise<string> {\n  const utils = await utilsAsync();\n  return utils.sha256(`${secretPath}/verified`);\n}\n\nexport type KeyExchangeErrorCode = 'invalid_parcel_format' | 'invalid_v1_parcel_format' | 'different_key_exchange_version';\ntype KeyExchangeResult =\n  {type: \"key\", key: Uint8Array, verificationCode: string} |\n  {type: \"error\", errorCode: KeyExchangeErrorCode};\n\nexport async function keyExchange(serverUrl: string, type: 'sender' | 'receiver', secretPath: string): Promise<KeyExchangeResult> {\n  const KEY_EXCHANGE_VERSION = 1;\n  // 256 is max value for deriveBits()\n  const KEY_BITS = 256;\n  // Create ECDH key pair\n  const keyPair: CryptoKeyPair = await window.crypto.subtle.generateKey(\n    { name: 'ECDH', namedCurve: 'P-256'},\n    false,\n    ['deriveKey', 'deriveBits']\n  );\n  // Get public key as JWK\n  // NOTE: kty should be 'EC' because it's ECDH key\n  const publicKeyJwk = await crypto.subtle.exportKey(\n    'jwk',\n    keyPair.publicKey!\n  ) as JsonWebKey & {kty: 'EC'};\n  const keyExchangeParcel: KeyExchangeV1Parcel = {\n    version: KEY_EXCHANGE_VERSION,\n    encryptPublicJwk: publicKeyJwk,\n  };\n  const urlJoin = await urlJoinAsync();\n  const myPath = await keyExchangePath(type, secretPath);\n  const peerPath = await keyExchangePath(type === 'sender' ? 'receiver' : 'sender', secretPath);\n  // Exchange\n  const [, peerRes] = await Promise.all([\n    fetch(urlJoin(serverUrl, myPath), {method: 'POST', body: JSON.stringify(keyExchangeParcel)}),\n    fetch(urlJoin(serverUrl, peerPath)),\n  ]);\n  const peerPublicKeyExchangeEither: Validation<KeyExchangeParcel> = keyExchangeParcelType.decode(JSON.parse(await peerRes.text()));\n  if (peerPublicKeyExchangeEither._tag === 'Left') {\n    return {type: \"error\", errorCode: 'invalid_parcel_format'};\n  }\n  const peerPublicKeyExchange = peerPublicKeyExchangeEither.right;\n  if (KEY_EXCHANGE_VERSION !== peerPublicKeyExchange.version) {\n    return {type: \"error\", errorCode: 'different_key_exchange_version'};\n  }\n  const peerPublicKeyExchangeV1Either = keyExchangeV1ParcelType.decode(peerPublicKeyExchange);\n  if (peerPublicKeyExchangeV1Either._tag === 'Left') {\n    return {type: \"error\", errorCode: 'invalid_v1_parcel_format'};\n  }\n  const peerPublicKeyExchangeV1 = peerPublicKeyExchangeV1Either.right;\n  const peerPublicKey = await crypto.subtle.importKey(\n    'jwk',\n    peerPublicKeyExchangeV1.encryptPublicJwk,\n    {name: 'ECDH', namedCurve: 'P-256'},\n    false,\n    []\n  );\n  const keyBits: ArrayBuffer = await crypto.subtle.deriveBits(\n    { name: 'ECDH', public: peerPublicKey },\n    keyPair.privateKey!,\n    KEY_BITS,\n  );\n  const verificationCode = await generateVerificationCode(publicKeyJwk, peerPublicKeyExchangeV1.encryptPublicJwk);\n  return {\n    type: 'key',\n    key: new Uint8Array(keyBits),\n    verificationCode,\n  };\n}\n\nasync function generateVerificationCode(publicJwk1: JsonWebKey, publicJwk2: JsonWebKey) {\n  const {jwkThumbprintByEncoding} = await jwkThumbprintAsync();\n  const hashes = [\n    jwkThumbprintByEncoding(publicJwk1, 'SHA-256', 'hex'),\n    jwkThumbprintByEncoding(publicJwk2, 'SHA-256', 'hex'),\n  ];\n  const utils = await utilsAsync();\n  return (await utils.sha256(hashes.sort().join('-'))).substring(0, 32);\n}\n\nexport async function keyExchangeAndReceiveVerified(serverUrl: string, secretPath: string, protection: Protection, setVerificationStep: (step: VerificationStep) => void):\n  Promise<\n    {type: 'key', key: string | Uint8Array | undefined} |\n    {type: 'error', errorMessage: (lang: string) => string}\n    > {\n  switch (protection.type) {\n    case 'raw':\n      return {\n        type: 'key',\n        key: undefined,\n      };\n    case 'password':\n      return {\n        type: 'key',\n        key: protection.password,\n      };\n    case 'passwordless': {\n      // Key exchange\n      const keyExchangeRes = await keyExchange(serverUrl, 'receiver', secretPath);\n      if (keyExchangeRes.type === 'error') {\n        setVerificationStep({type: 'error'});\n        return {\n          type: \"error\",\n          errorMessage(lang) {\n            return strings(lang)['key_exchange_error'](keyExchangeRes.errorCode);\n          }\n        };\n      }\n      const {key, verificationCode} = keyExchangeRes;\n      setVerificationStep({type: 'verification_code_arrived', verificationCode, key});\n      const uint8ArrayToString = await uint8ArrayToStringAsync();\n      const urlJoin = await urlJoinAsync();\n      const path = urlJoin(serverUrl, await verifiedPath(secretPath));\n      // Get verified or not\n      const res = await fetch(path);\n      const utils = await utilsAsync();\n      // Decrypt body\n      const decryptedBody: Uint8Array = await utils.decrypt(new Uint8Array(await res.arrayBuffer()), key);\n      // Parse\n      const verifiedParcelEither: Validation<VerifiedParcel> = verifiedParcelType.decode(JSON.parse(uint8ArrayToString(decryptedBody)));\n      if (verifiedParcelEither._tag === \"Left\") {\n        return {\n          type: \"error\",\n          errorMessage(lang) {\n            return strings(lang)['key_exchange_error']('invalid_parcel_format');\n          }\n        };\n      }\n      const {verified} = verifiedParcelEither.right;\n      setVerificationStep({type: 'verified', verified});\n      if (!verified) {\n        return {\n          type: \"error\",\n          errorMessage(lang) {\n            return strings(lang)['sender_not_verified'];\n          }\n        };\n      }\n      return {\n        type: 'key',\n        key,\n      };\n    }\n  }\n}\n"],"sourceRoot":""}