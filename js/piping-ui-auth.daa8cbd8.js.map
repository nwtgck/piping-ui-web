{"version":3,"sources":["webpack:///./src/datatypes.ts","webpack:///./src/_piping-ui-auth.ts"],"names":["rsaOtherPrimesInfoFormat","d","r","t","ecJsonWebKeyFormat","alg","crv","dp","dq","e","ext","k","key_ops","kty","n","oth","p","q","qi","use","x","y","keyExchangeParcelFormat","version","encryptPublicJwk","verifiedParcelFormat","verified","utilsAsync","jwkThumbprintAsync","uint8ArrayToStringAsync","then","uint8ArrayToString","urlJoinAsync","default","keyExchangePath","type","secretPath","utils","sha256","verifiedPath","keyExchange","serverUrl","KEY_EXCHANGE_VERSION","KEY_BITS","window","crypto","subtle","generateKey","name","namedCurve","keyPair","exportKey","publicKey","publicKeyJwk","keyExchangeParcel","urlJoin","myPath","peerPath","Promise","all","fetch","method","body","JSON","stringify","peerRes","text","peerPublicKeyExchange","undefined","errorCode","importKey","peerPublicKey","deriveBits","public","privateKey","keyBits","generateVerificationCode","verificationCode","key","Uint8Array","publicJwk1","publicJwk2","jwkThumbprintByEncoding","hashes","sort","join","substring","keyExchangeAndReceiveVerified","protection","setVerificationStep","password","keyExchangeRes","errorMessage","lang","strings","path","res","arrayBuffer","decrypt","decryptedBody","verifiedParcel"],"mappings":"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","file":"js/piping-ui-auth.daa8cbd8.js","sourcesContent":["import {bool, num, str, literal, opt, arr, obj, TsType} from 'ts-json-validator';\n\nexport type Protection = NoProtection | PasswordProtection| PasswordlessProtection;\ntype NoProtection = {\n  type: 'raw'\n};\ntype PasswordProtection = {\n  type: 'password',\n  password: string,\n};\n// Password-inputless protection\ntype PasswordlessProtection = {\n  type: 'passwordless',\n};\n\nconst rsaOtherPrimesInfoFormat = obj({\n  d: opt(str),\n  r: opt(str),\n  t: opt(str),\n});\nconst ecJsonWebKeyFormat = obj({\n  alg: opt(str),\n  crv: opt(str),\n  d: opt(str),\n  dp: opt(str),\n  dq: opt(str),\n  e: opt(str),\n  ext: opt(bool),\n  k: opt(str),\n  key_ops: opt(arr(str)),\n  kty: literal('EC' as const),\n  n: opt(str),\n  oth: opt(arr(rsaOtherPrimesInfoFormat)),\n  p: opt(str),\n  q: opt(str),\n  qi: opt(str),\n  use: opt(str),\n  x: opt(str),\n  y: opt(str),\n});\nexport const keyExchangeParcelFormat = obj({\n  version: num,\n  // Public JWK for encryption\n  encryptPublicJwk: ecJsonWebKeyFormat,\n});\nexport type KeyExchangeParcel = TsType<typeof keyExchangeParcelFormat>;\n\nexport const verifiedParcelFormat = obj({\n  verified: bool,\n});\nexport type VerifiedParcel = TsType<typeof verifiedParcelFormat>;\n\nexport type VerificationStep =\n  {type: 'initial'} |\n  {type: 'error'} |\n  {type: 'verification_code_arrived', verificationCode: string, key: Uint8Array} |\n  {type: 'verified', verified: boolean};\n","// NOTE: Use `const pipingUiAuthAsync = import(/* webpackChunkName: \"piping-ui-auth\" */ \"@/_piping-ui-auth\");` to import this file\n\nimport {\n  KeyExchangeParcel,\n  keyExchangeParcelFormat,\n  Protection, VerificationStep,\n  VerifiedParcel,\n  verifiedParcelFormat\n} from \"@/datatypes\";\nimport {validatingParse} from 'ts-json-validator';\nimport {strings} from \"@/strings\";\nconst utilsAsync = () => import(\"@/utils\");\n\nconst jwkThumbprintAsync  = () => import(\"jwk-thumbprint\");\nconst uint8ArrayToStringAsync = () => import('binconv/dist/src/uint8ArrayToString').then(p => p.uint8ArrayToString);\nconst urlJoinAsync = () => import('url-join').then(p => p.default);\n\nasync function keyExchangePath(type: 'sender' | 'receiver', secretPath: string): Promise<string> {\n  const utils = await utilsAsync();\n  return utils.sha256(`${secretPath}/key_exchange/${type}`);\n}\n\nexport async function verifiedPath(secretPath: string): Promise<string> {\n  const utils = await utilsAsync();\n  return utils.sha256(`${secretPath}/verified`);\n}\n\nexport type KeyExchangeErrorCode = 'invalid_parcel_format' | 'different_key_exchange_version';\ntype KeyExchangeResult =\n  {type: \"key\", key: Uint8Array, verificationCode: string} |\n  {type: \"error\", errorCode: KeyExchangeErrorCode};\n\nexport async function keyExchange(serverUrl: string, type: 'sender' | 'receiver', secretPath: string): Promise<KeyExchangeResult> {\n  const KEY_EXCHANGE_VERSION = 1;\n  // 256 is max value for deriveBits()\n  const KEY_BITS = 256;\n  // Create ECDH key pair\n  const keyPair: CryptoKeyPair = await window.crypto.subtle.generateKey(\n    { name: 'ECDH', namedCurve: 'P-256'},\n    false,\n    ['deriveKey', 'deriveBits']\n  );\n  // Get public key as JWK\n  // NOTE: kty should be 'EC' because it's ECDH key\n  const publicKeyJwk = await crypto.subtle.exportKey(\n    'jwk',\n    keyPair.publicKey\n  ) as JsonWebKey & {kty: 'EC'};\n  const keyExchangeParcel: KeyExchangeParcel = {\n    version: KEY_EXCHANGE_VERSION,\n    encryptPublicJwk: publicKeyJwk,\n  };\n  const urlJoin = await urlJoinAsync();\n  const myPath = await keyExchangePath(type, secretPath);\n  const peerPath = await keyExchangePath(type === 'sender' ? 'receiver' : 'sender', secretPath);\n  // Exchange\n  const [_, peerRes] = await Promise.all([\n    fetch(urlJoin(serverUrl, myPath), {method: 'POST', body: JSON.stringify(keyExchangeParcel)}),\n    fetch(urlJoin(serverUrl, peerPath)),\n  ]);\n  const peerPublicKeyExchange: KeyExchangeParcel | undefined = validatingParse(keyExchangeParcelFormat, await peerRes.text());\n  if (peerPublicKeyExchange === undefined) {\n    return {type: \"error\", errorCode: 'invalid_parcel_format'};\n  }\n  if (KEY_EXCHANGE_VERSION !== peerPublicKeyExchange.version) {\n    return {type: \"error\", errorCode: 'different_key_exchange_version'};\n  }\n  const peerPublicKey = await crypto.subtle.importKey(\n    'jwk',\n    peerPublicKeyExchange.encryptPublicJwk,\n    {name: 'ECDH', namedCurve: 'P-256'},\n    false,\n    []\n  );\n  const keyBits: ArrayBuffer = await crypto.subtle.deriveBits(\n    { name: 'ECDH', public: peerPublicKey },\n    keyPair.privateKey,\n    KEY_BITS,\n  );\n  const verificationCode = await generateVerificationCode(publicKeyJwk, peerPublicKeyExchange.encryptPublicJwk);\n  return {\n    type: 'key',\n    key: new Uint8Array(keyBits),\n    verificationCode,\n  };\n}\n\nasync function generateVerificationCode(publicJwk1: JsonWebKey, publicJwk2: JsonWebKey) {\n  const {jwkThumbprintByEncoding} = await jwkThumbprintAsync();\n  const hashes = [\n    jwkThumbprintByEncoding(publicJwk1, 'SHA-256', 'hex'),\n    jwkThumbprintByEncoding(publicJwk2, 'SHA-256', 'hex'),\n  ];\n  const utils = await utilsAsync();\n  return (await utils.sha256(hashes.sort().join('-'))).substring(0, 32);\n}\n\nexport async function keyExchangeAndReceiveVerified(serverUrl: string, secretPath: string, protection: Protection, setVerificationStep: (step: VerificationStep) => void):\n  Promise<\n    {type: 'key', key: string | Uint8Array | undefined} |\n    {type: 'error', errorMessage: (lang: string) => string}\n    > {\n  switch (protection.type) {\n    case 'raw':\n      return {\n        type: 'key',\n        key: undefined,\n      };\n    case 'password':\n      return {\n        type: 'key',\n        key: protection.password,\n      };\n    case 'passwordless': {\n      // Key exchange\n      const keyExchangeRes = await keyExchange(serverUrl, 'receiver', secretPath);\n      if (keyExchangeRes.type === 'error') {\n        setVerificationStep({type: 'error'});\n        return {\n          type: \"error\",\n          errorMessage(lang) {\n            return strings(lang)['key_exchange_error'](keyExchangeRes.errorCode);\n          }\n        };\n      }\n      const {key, verificationCode} = keyExchangeRes;\n      setVerificationStep({type: 'verification_code_arrived', verificationCode, key});\n      const uint8ArrayToString = await uint8ArrayToStringAsync();\n      const urlJoin = await urlJoinAsync();\n      const path = urlJoin(serverUrl, await verifiedPath(secretPath));\n      // Get verified or not\n      const res = await fetch(path);\n      const utils = await utilsAsync();\n      // Decrypt body\n      const decryptedBody: Uint8Array = await utils.decrypt(new Uint8Array(await res.arrayBuffer()), key);\n      // Parse\n      const verifiedParcel: VerifiedParcel | undefined = validatingParse(verifiedParcelFormat, uint8ArrayToString(decryptedBody));\n      if (verifiedParcel === undefined) {\n        return {\n          type: \"error\",\n          errorMessage(lang) {\n            return strings(lang)['key_exchange_error']('invalid_parcel_format');\n          }\n        };\n      }\n      const {verified} = verifiedParcel;\n      setVerificationStep({type: 'verified', verified});\n      if (!verified) {\n        return {\n          type: \"error\",\n          errorMessage(lang) {\n            return strings(lang)['sender_not_verified'];\n          }\n        };\n      }\n      return {\n        type: 'key',\n        key,\n      };\n    }\n  }\n}\n"],"sourceRoot":""}